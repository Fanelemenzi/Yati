{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Yati Technical Documentation Welcome to Yati Project Technical Documentation. This technical documentation is designed for new user and contributors to the Yati Codebase. It will allows them to familarise themselves with the codebase and how it works for easier and faster intergration to the project. For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-yati-technical-documentation","text":"Welcome to Yati Project Technical Documentation. This technical documentation is designed for new user and contributors to the Yati Codebase. It will allows them to familarise themselves with the codebase and how it works for easier and faster intergration to the project. For full documentation visit mkdocs.org .","title":"Welcome to Yati Technical Documentation"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"contribute/","text":"Contributing to Yati Project Welcome to the Yati community. We happy and excited you choose us for oyur open source contribution. Contribution Guide Zulip development community The primary communication forum for the Yati project is the discord server hosted at discord.com: Users and administrators of the Yati project stop by to ask questions, offer feedback, and participate in product design discussions. Contributors to the project , including the core Yati project team, discuss ongoing and future projects, brainstorm ideas, and generally help each other out. Everyone is welcome to sign up and participate \u2014 we love hearing from our users! Public streams in the community receive thousands of messages a week. To learn how to get started participating in the community, including community norms and where to post, check out our Yati development community guide . The Yati project community is governed by a code of conduct . Ways to contribute To make a code or documentation contribution, read our step-by-step guide to getting started with the Zulip codebase. A small sample of the type of work that needs doing: Bug squashing and feature development on our Python/Django backend, web frontend, Flutter mobile app in beta, or Electron desktop app. Building out our Python API and bots framework. Writing an integration. Improving our user or developer documentation. Reviewing code and manually testing pull requests. Non-code contributions: Some of the most valuable ways to contribute don\u2019t require touching the codebase at all. For example, you can: Report issues, including both feature requests and bug reports. Give feedback if you are evaluating or using Yati. Participate thoughtfully in design discussions. Your first codebase contribution This section has a step by step guide to starting as a Yati codebase contributor. It\u2019s long, but don\u2019t worry about doing all the steps perfectly; no one gets it right the first time, and there are a lot of people available to help. First, make an account on the Yati discord server, paying special attention to the community norms. If you\u2019d like, introduce yourself in #new members channel, using your name as the topic. Bonus: tell us about your first impressions of Yati, and anything that felt confusing/broken or interesting/helpful as you started using the product. Read What makes a great Zulip contributor. Set up the development environment for the Zulip codebase you want to work on, and start getting familiar with the code. For the server and web app: Install the development environment , getting help in #provision help if you run into any troubles. Familiarize yourself with using the development environment. Go through the new application feature tutorial to get familiar with how the Yati codebase is organized and how to find code in it. Read the Zulip guide to Git if you are unfamiliar with Git or Yati\u2019s rebase-based Git workflow, getting help in #git help if you run into any troubles. Even Git experts should read the Yati-specific Git tools page. Where to look for an issue Now you\u2019re ready to pick your first issue! Yati has several repositories you can check out, depending on your interests. There are hundreds of open issues in the main Yati repository . You can look through issues tagged with the \u201chelp wanted\u201d label, which is used to indicate the issues that are ready for contributions. Some repositories also use the \u201cgood first issue\u201d label to tag issues that are especially approachable for new contributors. Picking an issue to work on There\u2019s a lot to learn while making your first pull request, so start small! Many first contributions have fewer than 10 lines of changes (not counting changes to tests). We recommend the following process for finding an issue to work on: Read the description of an issue tagged with the \u201chelp wanted\u201d label and make sure you understand it. If it seems promising, poke around the product (on discord server or in the Github comments) until you know how the piece being described fits into the bigger picture. If after some exploration the description seems confusing or ambiguous, post a question on the GitHub issue, as others may benefit from the clarification as well. When you find an issue you like, try to get started working on it. See if you can find the part of the code you\u2019ll need to modify (git grep is your friend!) and get some idea of how you\u2019ll approach the problem. If you feel lost, that\u2019s OK! Go through these steps again with another issue. There\u2019s plenty to work on, and the exploration you do will help you learn more about the project. Note that you are not claiming an issue while you are iterating through steps 1-4. Before you claim an issue, you should be confident that you will be able to tackle it effectively.","title":"Contributing to Yati"},{"location":"contribute/#contributing-to-yati-project","text":"Welcome to the Yati community. We happy and excited you choose us for oyur open source contribution.","title":"Contributing to Yati Project"},{"location":"contribute/#contribution-guide","text":"","title":"Contribution Guide"},{"location":"contribute/#zulip-development-community","text":"The primary communication forum for the Yati project is the discord server hosted at discord.com: Users and administrators of the Yati project stop by to ask questions, offer feedback, and participate in product design discussions. Contributors to the project , including the core Yati project team, discuss ongoing and future projects, brainstorm ideas, and generally help each other out. Everyone is welcome to sign up and participate \u2014 we love hearing from our users! Public streams in the community receive thousands of messages a week. To learn how to get started participating in the community, including community norms and where to post, check out our Yati development community guide . The Yati project community is governed by a code of conduct .","title":"Zulip development community"},{"location":"contribute/#ways-to-contribute","text":"To make a code or documentation contribution, read our step-by-step guide to getting started with the Zulip codebase. A small sample of the type of work that needs doing: Bug squashing and feature development on our Python/Django backend, web frontend, Flutter mobile app in beta, or Electron desktop app. Building out our Python API and bots framework. Writing an integration. Improving our user or developer documentation. Reviewing code and manually testing pull requests. Non-code contributions: Some of the most valuable ways to contribute don\u2019t require touching the codebase at all. For example, you can: Report issues, including both feature requests and bug reports. Give feedback if you are evaluating or using Yati. Participate thoughtfully in design discussions.","title":"Ways to contribute"},{"location":"contribute/#your-first-codebase-contribution","text":"This section has a step by step guide to starting as a Yati codebase contributor. It\u2019s long, but don\u2019t worry about doing all the steps perfectly; no one gets it right the first time, and there are a lot of people available to help. First, make an account on the Yati discord server, paying special attention to the community norms. If you\u2019d like, introduce yourself in #new members channel, using your name as the topic. Bonus: tell us about your first impressions of Yati, and anything that felt confusing/broken or interesting/helpful as you started using the product. Read What makes a great Zulip contributor. Set up the development environment for the Zulip codebase you want to work on, and start getting familiar with the code. For the server and web app: Install the development environment , getting help in #provision help if you run into any troubles. Familiarize yourself with using the development environment. Go through the new application feature tutorial to get familiar with how the Yati codebase is organized and how to find code in it. Read the Zulip guide to Git if you are unfamiliar with Git or Yati\u2019s rebase-based Git workflow, getting help in #git help if you run into any troubles. Even Git experts should read the Yati-specific Git tools page.","title":"Your first codebase contribution"},{"location":"contribute/#where-to-look-for-an-issue","text":"Now you\u2019re ready to pick your first issue! Yati has several repositories you can check out, depending on your interests. There are hundreds of open issues in the main Yati repository . You can look through issues tagged with the \u201chelp wanted\u201d label, which is used to indicate the issues that are ready for contributions. Some repositories also use the \u201cgood first issue\u201d label to tag issues that are especially approachable for new contributors.","title":"Where to look for an issue"},{"location":"contribute/#picking-an-issue-to-work-on","text":"There\u2019s a lot to learn while making your first pull request, so start small! Many first contributions have fewer than 10 lines of changes (not counting changes to tests). We recommend the following process for finding an issue to work on: Read the description of an issue tagged with the \u201chelp wanted\u201d label and make sure you understand it. If it seems promising, poke around the product (on discord server or in the Github comments) until you know how the piece being described fits into the bigger picture. If after some exploration the description seems confusing or ambiguous, post a question on the GitHub issue, as others may benefit from the clarification as well. When you find an issue you like, try to get started working on it. See if you can find the part of the code you\u2019ll need to modify (git grep is your friend!) and get some idea of how you\u2019ll approach the problem. If you feel lost, that\u2019s OK! Go through these steps again with another issue. There\u2019s plenty to work on, and the exploration you do will help you learn more about the project. Note that you are not claiming an issue while you are iterating through steps 1-4. Before you claim an issue, you should be confident that you will be able to tackle it effectively.","title":"Picking an issue to work on"},{"location":"devenv/","text":"Developement Environment Installation Requirements The Yati project require a level of spefication in hardware and software to fucntion best. The project can be developed using different IDEs or any IDE of your choice. It can run on macOS, Windows and Linux. Yati requires the set of Flutter SDK and the Dart SDK. Please follow the documentation for setup in Windows , setup in macOS and in Linux . To work on Yati project, Git is required on local IDE to track any changes to the project. Minimum Recommended Hardware Setup The following offers a guidelines for the minimum recommended hardwares setup to run the project locally on your IDE environment: Operating System: Windows/macOS/Linux RAM: 8GB Disk Storage: 5GB Others: Wifi, USB compatibility. IDE Setup: Visual Studio Code Visual Studio Code is the recommended IDE for the Yati project due to its simplicity, ease of use and recommdendation by the Flutter Team. The official flutter installation guide includes the installation of VScode but its okay if you have one already installed. VSCode Plugins To setup VScode for the Yati project, install the following plugins: Flutter Plugin Dart Plugin Developer Tutorials Working on a issue Backend Changes Frontend Changes Documentaation Changes After implementing the new feature, you should document it and update any existing documentation that might be relevant to the new feature. This include checking for in code documentation explaining functions and methods. If you had any changes to document, go to yati/Docs/docs/ and find the relevant file to document your changes. Version Documentation This section of documentation details out the documentation for published version of Yati for public use. Yati Version 1.0.1: Realease 2 Reading Materials Here you can find a list of relevant resources that you may find useful for learning new skills, or polishing the ones you already have. The topics cover a wide variety of topics, from basic Dart and Flutter coding to general developing guidelines. Learning Path - Dart Video - Dart Video - Flutter Development Package Documentation - Flutter and Dart Packages Beginner Tutorial Video - Flutter Project Tutorial","title":"Development Environment"},{"location":"devenv/#developement-environment-installation","text":"","title":"Developement Environment Installation"},{"location":"devenv/#requirements","text":"The Yati project require a level of spefication in hardware and software to fucntion best. The project can be developed using different IDEs or any IDE of your choice. It can run on macOS, Windows and Linux. Yati requires the set of Flutter SDK and the Dart SDK. Please follow the documentation for setup in Windows , setup in macOS and in Linux . To work on Yati project, Git is required on local IDE to track any changes to the project.","title":"Requirements"},{"location":"devenv/#minimum-recommended-hardware-setup","text":"The following offers a guidelines for the minimum recommended hardwares setup to run the project locally on your IDE environment: Operating System: Windows/macOS/Linux RAM: 8GB Disk Storage: 5GB Others: Wifi, USB compatibility.","title":"Minimum Recommended Hardware Setup"},{"location":"devenv/#ide-setup-visual-studio-code","text":"Visual Studio Code is the recommended IDE for the Yati project due to its simplicity, ease of use and recommdendation by the Flutter Team. The official flutter installation guide includes the installation of VScode but its okay if you have one already installed.","title":"IDE Setup: Visual Studio Code"},{"location":"devenv/#vscode-plugins","text":"To setup VScode for the Yati project, install the following plugins: Flutter Plugin Dart Plugin","title":"VSCode Plugins"},{"location":"devenv/#developer-tutorials","text":"","title":"Developer Tutorials"},{"location":"devenv/#working-on-a-issue","text":"","title":"Working on a issue"},{"location":"devenv/#backend-changes","text":"","title":"Backend Changes"},{"location":"devenv/#frontend-changes","text":"","title":"Frontend Changes"},{"location":"devenv/#documentaation-changes","text":"After implementing the new feature, you should document it and update any existing documentation that might be relevant to the new feature. This include checking for in code documentation explaining functions and methods. If you had any changes to document, go to yati/Docs/docs/ and find the relevant file to document your changes.","title":"Documentaation Changes"},{"location":"devenv/#version-documentation","text":"This section of documentation details out the documentation for published version of Yati for public use.","title":"Version Documentation"},{"location":"devenv/#yati-version-101-realease-2","text":"","title":"Yati Version 1.0.1: Realease 2"},{"location":"devenv/#reading-materials","text":"Here you can find a list of relevant resources that you may find useful for learning new skills, or polishing the ones you already have. The topics cover a wide variety of topics, from basic Dart and Flutter coding to general developing guidelines. Learning Path - Dart Video - Dart Video - Flutter Development Package Documentation - Flutter and Dart Packages Beginner Tutorial Video - Flutter Project Tutorial","title":"Reading Materials"},{"location":"gitguide/","text":"Git Guide Set up Git If you\u2019re already using Git, have a client you like, and a GitHub account, you can skip this section. Otherwise, read on! Install and configure Git, join GitHub If you\u2019re not already using Git, you might need to install and configure it. You\u2019ll also need a GitHub account, which you can sign up for here . Important Git terms When you install Git, it adds a manual entry for gitglossary. You can view this glossary by running man gitglossary. Below we\u2019ve included the Git terms you\u2019ll encounter most often along with their definitions from gitglossary. branch A \u201cbranch\u201d is an active line of development. The most recent commit on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch head, which moves forward as additional development is done on the branch. A single Git repository can track an arbitrary number of branches, but your working tree is associated with just one of them (the \u201ccurrent\u201d or \u201cchecked out\u201d branch), and HEAD points to that branch. cache Obsolete for: index checkout The action of updating all or part of the working tree with a tree object or blob from the object database, and updating the index and HEAD if the whole working tree has been pointed at a new branch. commit As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word \u201ccommit\u201d is often used by Git in the same places other revision control systems use the words \u201crevision\u201d or \u201cversion\u201d. Also used as a short hand for commit object. As a verb: The action of storing a new snapshot of the project\u2019s state in the Git history, by creating a new commit representing the current state of the index and advancing HEAD to point at the new fast-forward A fast-forward is a special type of merge where you have a revision and you are \u201cmerging\u201d another branch\u2019s changes that happen to be a descendant of what you have. In such these cases, you do not make a new merge commit but instead just update to their revision. This will happen frequently on a remote-tracking branch of a remote repository. fetch Fetching a branch means to get the branch\u2019s head ref from a remote repository, to find out which objects are missing from the local object database, and to get them, too. See also git-fetch(1) hash In Git\u2019s context, synonym for object name. head A named reference to the commit at the tip of a branch. Heads are stored in a file in $GIT_DIR/refs/heads/ directory, except when using packed refs. See also git-pack-refs(1). HEAD The current branch. In more detail: Your working tree is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the heads in your repository, except when using a detached HEAD, in which case it directly references an arbitrary commit. index A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your working tree. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when merging. pull Pulling a branch means to fetch it and merge it. See also git-pull(1) push Pushing a branch means to get the branch\u2019s head ref from a remote repository, find out if it is a direct ancestor to the branch\u2019s local head ref, and in that case, putting all objects, which are reachable from the local head ref, and which are missing from the remote repository, into the remote object database, and updating the remote head ref. If the remote head is not an ancestor to the local head, the push fails. rebase To reapply a series of changes from a branch to a different base, and reset the head of that branch to the result. Get Yati Code Yati uses a forked-repo and rebase-oriented workflow. This means that all contributors create a fork of the Yati repository they want to contribute to and then submit pull requests to the upstream repository to have their contributions reviewed and accepted. We also recommend you work on feature branches. Step 1: Create your fork The following steps you\u2019ll only need to do the first time you set up a machine for contributing to a given Yati project. You\u2019ll need to repeat the steps for any additional Yati projects that you may work on. The first thing you\u2019ll want to do to contribute to Yati is fork (see how) the appropriate Yati repository. Step 2: Clone to your machine Next, clone your fork to your local machine with the following command on your working directory git clone https://github.com/Fanelemenzi/Yati.git Step 3: Open Project on your IDE Once you cloned the project, open the cloned forlder with your prefered IDE or the recommended one. Working Copies When you work on Yati code, there are three copies of the Yati Git repository that you are generally concerned with: The main remote repository. This is the official Yati repository on GitHub. You probably don\u2019t have write access to this repository. The origin remote: Your personal remote repository on GitHub. You\u2019ll use this to share your code and create pull requests. local copy: This lives on your laptop or your remote dev instance, and is what you\u2019ll use to make changes and create commits. When you work on Yati code, you will end up moving code between the various working copies. Workflows Sometimes you need to get commits. Here are some scenarios: You may fork the official Yati repository to your GitHub fork. You may fetch commits from the official Yati repository to your local copy. You occasionally may fetch commits from your forked copy. Sometimes you want to publish commits. Here are some scenarios: You push code from your local copy to your GitHub fork. (You usually want to put the commit on a feature branch.) You submit a PR to the official Yati repo. Finally, the Yati core team will occasionally want your changes! The Yati core team can accept your changes and add them to the official repo, usually on the main branch. Relevant Git commands The following commands are useful for moving commits between working copies: git fetch : This grabs code from another repository to your local copy. (Defaults to fetching from your default remote, origin ). git fetch upstream : This grabs code from the upstream repository to your local copy. git push : This pushes code from your local repository to one of the remotes. git remote : This helps you configure short names for remotes. git pull : This pulls code, but by default creates a merge commit (which you definitely don\u2019t want). However, if you\u2019ve followed our cloning documentation, this will do git pull --rebase instead, which is the only mode you\u2019ll want to use when working on Yati. Using Git as you work Know what branch you're working on When using Git, it\u2019s important to know which branch you currently have checked out because most Git commands implicitly operate on the current branch. You can determine the currently checked out branch several ways. One way is with git status: $ git status On branch issue-demo nothing to commit, working directory clean Another is with git branch which will display all local branches, with a star next to the current branch: $ git branch * issue-demo main To see even more information about your branches, including remote branches, use git branch -vva: $ git branch -vva * issue-123 517468b troubleshooting tip about provisioning main f0eaee6 [origin/main] bug: Fix traceback in get_missed_message_token_from_address(). remotes/origin/HEAD -> origin/main remotes/origin/issue-1234 4aeccb7 Another test commit, with longer message. remotes/origin/main f0eaee6 bug: Fix traceback in get_missed_message_token_from_address(). remotes/upstream/main dbeab6a Optimize checks of test database state by moving into Python. Work on a feature branch One way to keep your work organized is to create a branch for each issue or feature. Recall from how Git is different that Git is designed for lightweight branching and merging. You can and should create as many branches as you\u2019d like. Next, from your main branch, create a new tracking branch, providing a descriptive name for your feature branch: $ git checkout main Switched to branch 'main' $ git checkout -b issue-1755-fail2ban Switched to a new branch 'issue-1755-fail2ban' Alternatively, you can create a new branch explicitly based off main branch: $ git checkout -b issue-1755-fail2ban upstream/main Switched to a new branch 'issue-1755-fail2ban' Now you're ready to work on the issue or feature. Stage Changes Recall that files tracked with Git have possible three states: committed, modified, and staged. To prepare a commit, first add the files with changes that you want to include in your commit to your staging area. You add both new files and existing ones. You can also remove files from staging when necessary. Get Status of working directory To see what files in the working directory have changes that have not been staged, use git status . If you have no changes in the working directory, you\u2019ll see something like this: $ git status On branch issue-123 nothing to commit, working directory clean If you have unstaged changes, you'll see something like this: On branch issue-123 Untracked files: (use \"git add <file>...\" to include in what will be committed) newfile.py nothing added to commit but untracked files present (use \"git add\" to track) Stage additions with git add To add changes to your staging area, use git add . Because git add is all about staging the changes you want to commit, you use it to add new files as well as files with changes to your staging area. Continuing our example from above, after we run git add newfile.py, we\u2019ll see the following from git status: On branch issue-123 Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: newfile.py You can view the changes in files you have staged with git diff --cached . To view changes to files you haven\u2019t yet staged, just use git diff . If you want to add all changes in the working directory, use git add -A documentation . You can also stage changes using your graphical Git client. If you stage a file, you can undo it with git reset HEAD <filename> . Here\u2019s an example where we stage a file test3.txt and then unstage it: $ git add test3.txt On branch issue-1234 Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: test3.txt $ git reset HEAD test3.txt git status On branch issue-1234 Untracked files: (use \"git add <file>...\" to include in what will be committed) test3.txt nothing added to commit but untracked files present (use \"git add\" to track) Commit Changes When you\u2019ve staged all your changes, you\u2019re ready to commit. You can do this with git commit -m \"My commit message.\" to include a commit message. Here\u2019s an example of committing with the -m for a one-line commit message: $ git commit -m \"Add a test commit for docs.\" [issue-123 173e17a] Add a test commit for docs. 1 file changed, 1 insertion(+) create mode 100644 newfile.py You can also use git commit without the -m option and your editor to open, allowing you to easily draft a multi-line commit message. How long your commit message should be depends on where you are in your work. Using short, one-line messages for commits related to in-progress work makes sense. For a commit that you intend to be final or that encompasses a significant amount or complex work, you should include a longer message. Keep in mind that your commit should contain a \u2018minimal coherent idea\u2019 and have a quality commit message. Here\u2019s an example of a longer commit message that will be used for a pull request: Integrate Fail2Ban. Updates Zulip logging to put an unambiguous entry into the logs such that fail2ban can be configured to look for these entries. Tested on my local Ubuntu development server, but would appreciate someone testing on a production install with more users. Fixes #1755. The first line is the summary. It\u2019s a complete sentence, ending in a period. It uses a present-tense action verb, \u201cIntegrate\u201d, rather than \u201cIntegrates\u201d or \u201cIntegrating\u201d. The following paragraphs are full prose and explain why and how the change was made. It explains what testing was done and asks specifically for further testing in a more production-like environment. The final paragraph indicates that this commit addresses and fixes issue #1755. When you submit your pull request, GitHub will detect and link this reference to the appropriate issue. Once your commit is merged into upstream/main, GitHub will automatically close the referenced issue. See Closing issues via commit messages for details. Note in particular that GitHub\u2019s regular expressions for this feature are sloppy, so phrases like Partially fixes #1234 will automatically close the issue. Phrases like Fixes part of #1234 are a good alternative. Make as many commits as you need to address the issue or implement your feature. Push your commits to Github As you\u2019re working, it\u2019s a good idea to frequently push your changes to GitHub. This ensures your work is backed up should something happen to your local machine and allows others to follow your progress. It also allows you to work from multiple computers without losing work. Pushing to a feature branch is just like pushing to main: $ git push origin <branch-name> Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git * [new branch] issue-demo -> issue- If you want to see what Git will do without actually performing the push, add the -n (dry-run) option: git push -n origin <branch-name> . If everything looks good, re-run the push command without -n. If the feature branch does not already exist on GitHub, it will be created when you push and you\u2019ll see * [new branch] in the command output. Get and stay out of trouble Git is a powerful yet complex version control system. Even for contributors experienced at using version control, it can be confusing. The good news is that nearly all Git actions add information to the Git database, rather than removing it. As such, it\u2019s hard to make Git perform actions that you can\u2019t undo. However, Git can\u2019t undo what it doesn\u2019t know about, so it\u2019s a good practice to frequently commit your changes and frequently push your commits to your remote repository. Undo a merge commit A merge commit is a special type of commit that has two parent commits. It\u2019s created by Git when you merge one branch into another and the last commit on your current branch is not a direct ancestor of the branch you are trying to merge in. This happens quite often in a busy project like Zulip where there are many contributors because upstream/zulip will have new commits while you\u2019re working on a feature or bugfix. In order for Git to merge your changes and the changes that have occurred on zulip/upstream since you first started your work, it must perform a three-way merge and create a merge commit. Merge commits aren\u2019t bad, however, Zulip doesn\u2019t use them. Instead Zulip uses a forked-repo, rebase-oriented workflow. A merge commit is usually created when you\u2019ve run git pull or git merge. You\u2019ll know you\u2019re creating a merge commit if you\u2019re prompted for a commit message and the default is something like this: Merge branch 'main' of https://github.com/yati # Please enter a commit message to explain why this merge is necessary, # especially if it merges an updated upstream into a topic branch. # # Lines starting with '#' will be ignored, and an empty message aborts # the commit. And the first entry for git log will show something like: commit e5f8211a565a5a5448b93e98ed56415255546f94 Merge: 13bea0e e0c10ed Author: Christie Koehler <ck@christi3k.net> Date: Mon Oct 10 13:25:51 2016 -0700 Merge branch 'main' of https://github.com/yati Some graphical Git clients may also create merge commits. To undo a merge commit, first run git reflog to identify the commit you want to roll back to: git reflog e5f8211 HEAD@{0}: pull upstream main: Merge made by the 'recursive' strategy. 13bea0e HEAD@{1}: commit: test commit for docs. Reflog output will be long. The most recent Git refs will be listed at the top. In the example above e5f8211 HEAD@{0} : is the merge commit made automatically by git pull and 13bea0e HEAD@{1}: is the last commit I made before running git pull , the commit that I want to rollback to. Once you\u2019d identified the ref you want to revert to, you can do so with git reset: git reset --hard 13bea0e HEAD is now at 13bea0e test commit for docs. Restore a lost commit We\u2019ve mentioned you can use git reset --hard to rollback to a previous commit. What if you run git reset --hard and then realize you actually need one or more of the commits you just discarded? No problem, you can restore them with git cherry-pick (docs). For example, let\u2019s say you just committed \u201csome work\u201d and your git log looks like this: * 67aea58 (HEAD -> main) some work * 13bea0e test commit for docs. You then mistakenly run git reset --hard 13bea0e : git reset --hard 13bea0e HEAD is now at 13bea0e test commit for docs. git log * 13bea0e (HEAD -> main) test commit for docs. And then realize you actually needed to keep commit 67aea58. First, use git reflog to confirm that commit you want to restore and then run git cherry-pick : git reflog 13bea0e HEAD@{0}: reset: moving to 13bea0e 67aea58 HEAD@{1}: commit: some work git cherry-pick 67aea58 [main 67aea58] some work Date: Thu Oct 13 11:51:19 2016 -0700 1 file changed, 1 insertion(+) create mode 100644 test4.txt","title":"Git Guide"},{"location":"gitguide/#git-guide","text":"","title":"Git Guide"},{"location":"gitguide/#set-up-git","text":"If you\u2019re already using Git, have a client you like, and a GitHub account, you can skip this section. Otherwise, read on!","title":"Set up Git"},{"location":"gitguide/#install-and-configure-git-join-github","text":"If you\u2019re not already using Git, you might need to install and configure it. You\u2019ll also need a GitHub account, which you can sign up for here .","title":"Install and configure Git, join GitHub"},{"location":"gitguide/#important-git-terms","text":"When you install Git, it adds a manual entry for gitglossary. You can view this glossary by running man gitglossary. Below we\u2019ve included the Git terms you\u2019ll encounter most often along with their definitions from gitglossary. branch A \u201cbranch\u201d is an active line of development. The most recent commit on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch head, which moves forward as additional development is done on the branch. A single Git repository can track an arbitrary number of branches, but your working tree is associated with just one of them (the \u201ccurrent\u201d or \u201cchecked out\u201d branch), and HEAD points to that branch. cache Obsolete for: index checkout The action of updating all or part of the working tree with a tree object or blob from the object database, and updating the index and HEAD if the whole working tree has been pointed at a new branch. commit As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word \u201ccommit\u201d is often used by Git in the same places other revision control systems use the words \u201crevision\u201d or \u201cversion\u201d. Also used as a short hand for commit object. As a verb: The action of storing a new snapshot of the project\u2019s state in the Git history, by creating a new commit representing the current state of the index and advancing HEAD to point at the new fast-forward A fast-forward is a special type of merge where you have a revision and you are \u201cmerging\u201d another branch\u2019s changes that happen to be a descendant of what you have. In such these cases, you do not make a new merge commit but instead just update to their revision. This will happen frequently on a remote-tracking branch of a remote repository. fetch Fetching a branch means to get the branch\u2019s head ref from a remote repository, to find out which objects are missing from the local object database, and to get them, too. See also git-fetch(1) hash In Git\u2019s context, synonym for object name. head A named reference to the commit at the tip of a branch. Heads are stored in a file in $GIT_DIR/refs/heads/ directory, except when using packed refs. See also git-pack-refs(1). HEAD The current branch. In more detail: Your working tree is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the heads in your repository, except when using a detached HEAD, in which case it directly references an arbitrary commit. index A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your working tree. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when merging. pull Pulling a branch means to fetch it and merge it. See also git-pull(1) push Pushing a branch means to get the branch\u2019s head ref from a remote repository, find out if it is a direct ancestor to the branch\u2019s local head ref, and in that case, putting all objects, which are reachable from the local head ref, and which are missing from the remote repository, into the remote object database, and updating the remote head ref. If the remote head is not an ancestor to the local head, the push fails. rebase To reapply a series of changes from a branch to a different base, and reset the head of that branch to the result.","title":"Important Git terms"},{"location":"gitguide/#get-yati-code","text":"Yati uses a forked-repo and rebase-oriented workflow. This means that all contributors create a fork of the Yati repository they want to contribute to and then submit pull requests to the upstream repository to have their contributions reviewed and accepted. We also recommend you work on feature branches.","title":"Get Yati Code"},{"location":"gitguide/#step-1-create-your-fork","text":"The following steps you\u2019ll only need to do the first time you set up a machine for contributing to a given Yati project. You\u2019ll need to repeat the steps for any additional Yati projects that you may work on. The first thing you\u2019ll want to do to contribute to Yati is fork (see how) the appropriate Yati repository.","title":"Step 1: Create your fork"},{"location":"gitguide/#step-2-clone-to-your-machine","text":"Next, clone your fork to your local machine with the following command on your working directory git clone https://github.com/Fanelemenzi/Yati.git","title":"Step 2: Clone to your machine"},{"location":"gitguide/#step-3-open-project-on-your-ide","text":"Once you cloned the project, open the cloned forlder with your prefered IDE or the recommended one.","title":"Step 3: Open Project on your IDE"},{"location":"gitguide/#working-copies","text":"When you work on Yati code, there are three copies of the Yati Git repository that you are generally concerned with: The main remote repository. This is the official Yati repository on GitHub. You probably don\u2019t have write access to this repository. The origin remote: Your personal remote repository on GitHub. You\u2019ll use this to share your code and create pull requests. local copy: This lives on your laptop or your remote dev instance, and is what you\u2019ll use to make changes and create commits. When you work on Yati code, you will end up moving code between the various working copies.","title":"Working Copies"},{"location":"gitguide/#workflows","text":"Sometimes you need to get commits. Here are some scenarios: You may fork the official Yati repository to your GitHub fork. You may fetch commits from the official Yati repository to your local copy. You occasionally may fetch commits from your forked copy. Sometimes you want to publish commits. Here are some scenarios: You push code from your local copy to your GitHub fork. (You usually want to put the commit on a feature branch.) You submit a PR to the official Yati repo. Finally, the Yati core team will occasionally want your changes! The Yati core team can accept your changes and add them to the official repo, usually on the main branch.","title":"Workflows"},{"location":"gitguide/#relevant-git-commands","text":"The following commands are useful for moving commits between working copies: git fetch : This grabs code from another repository to your local copy. (Defaults to fetching from your default remote, origin ). git fetch upstream : This grabs code from the upstream repository to your local copy. git push : This pushes code from your local repository to one of the remotes. git remote : This helps you configure short names for remotes. git pull : This pulls code, but by default creates a merge commit (which you definitely don\u2019t want). However, if you\u2019ve followed our cloning documentation, this will do git pull --rebase instead, which is the only mode you\u2019ll want to use when working on Yati.","title":"Relevant Git commands"},{"location":"gitguide/#using-git-as-you-work","text":"","title":"Using Git as you work"},{"location":"gitguide/#know-what-branch-youre-working-on","text":"When using Git, it\u2019s important to know which branch you currently have checked out because most Git commands implicitly operate on the current branch. You can determine the currently checked out branch several ways. One way is with git status: $ git status On branch issue-demo nothing to commit, working directory clean Another is with git branch which will display all local branches, with a star next to the current branch: $ git branch * issue-demo main To see even more information about your branches, including remote branches, use git branch -vva: $ git branch -vva * issue-123 517468b troubleshooting tip about provisioning main f0eaee6 [origin/main] bug: Fix traceback in get_missed_message_token_from_address(). remotes/origin/HEAD -> origin/main remotes/origin/issue-1234 4aeccb7 Another test commit, with longer message. remotes/origin/main f0eaee6 bug: Fix traceback in get_missed_message_token_from_address(). remotes/upstream/main dbeab6a Optimize checks of test database state by moving into Python.","title":"Know what branch you're working on"},{"location":"gitguide/#work-on-a-feature-branch","text":"One way to keep your work organized is to create a branch for each issue or feature. Recall from how Git is different that Git is designed for lightweight branching and merging. You can and should create as many branches as you\u2019d like. Next, from your main branch, create a new tracking branch, providing a descriptive name for your feature branch: $ git checkout main Switched to branch 'main' $ git checkout -b issue-1755-fail2ban Switched to a new branch 'issue-1755-fail2ban' Alternatively, you can create a new branch explicitly based off main branch: $ git checkout -b issue-1755-fail2ban upstream/main Switched to a new branch 'issue-1755-fail2ban' Now you're ready to work on the issue or feature.","title":"Work on a feature branch"},{"location":"gitguide/#stage-changes","text":"Recall that files tracked with Git have possible three states: committed, modified, and staged. To prepare a commit, first add the files with changes that you want to include in your commit to your staging area. You add both new files and existing ones. You can also remove files from staging when necessary.","title":"Stage Changes"},{"location":"gitguide/#get-status-of-working-directory","text":"To see what files in the working directory have changes that have not been staged, use git status . If you have no changes in the working directory, you\u2019ll see something like this: $ git status On branch issue-123 nothing to commit, working directory clean If you have unstaged changes, you'll see something like this: On branch issue-123 Untracked files: (use \"git add <file>...\" to include in what will be committed) newfile.py nothing added to commit but untracked files present (use \"git add\" to track)","title":"Get Status of working directory"},{"location":"gitguide/#stage-additions-with-git-add","text":"To add changes to your staging area, use git add . Because git add is all about staging the changes you want to commit, you use it to add new files as well as files with changes to your staging area. Continuing our example from above, after we run git add newfile.py, we\u2019ll see the following from git status: On branch issue-123 Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: newfile.py You can view the changes in files you have staged with git diff --cached . To view changes to files you haven\u2019t yet staged, just use git diff . If you want to add all changes in the working directory, use git add -A documentation . You can also stage changes using your graphical Git client. If you stage a file, you can undo it with git reset HEAD <filename> . Here\u2019s an example where we stage a file test3.txt and then unstage it: $ git add test3.txt On branch issue-1234 Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) new file: test3.txt $ git reset HEAD test3.txt git status On branch issue-1234 Untracked files: (use \"git add <file>...\" to include in what will be committed) test3.txt nothing added to commit but untracked files present (use \"git add\" to track)","title":"Stage additions with git add"},{"location":"gitguide/#commit-changes","text":"When you\u2019ve staged all your changes, you\u2019re ready to commit. You can do this with git commit -m \"My commit message.\" to include a commit message. Here\u2019s an example of committing with the -m for a one-line commit message: $ git commit -m \"Add a test commit for docs.\" [issue-123 173e17a] Add a test commit for docs. 1 file changed, 1 insertion(+) create mode 100644 newfile.py You can also use git commit without the -m option and your editor to open, allowing you to easily draft a multi-line commit message. How long your commit message should be depends on where you are in your work. Using short, one-line messages for commits related to in-progress work makes sense. For a commit that you intend to be final or that encompasses a significant amount or complex work, you should include a longer message. Keep in mind that your commit should contain a \u2018minimal coherent idea\u2019 and have a quality commit message. Here\u2019s an example of a longer commit message that will be used for a pull request: Integrate Fail2Ban. Updates Zulip logging to put an unambiguous entry into the logs such that fail2ban can be configured to look for these entries. Tested on my local Ubuntu development server, but would appreciate someone testing on a production install with more users. Fixes #1755. The first line is the summary. It\u2019s a complete sentence, ending in a period. It uses a present-tense action verb, \u201cIntegrate\u201d, rather than \u201cIntegrates\u201d or \u201cIntegrating\u201d. The following paragraphs are full prose and explain why and how the change was made. It explains what testing was done and asks specifically for further testing in a more production-like environment. The final paragraph indicates that this commit addresses and fixes issue #1755. When you submit your pull request, GitHub will detect and link this reference to the appropriate issue. Once your commit is merged into upstream/main, GitHub will automatically close the referenced issue. See Closing issues via commit messages for details. Note in particular that GitHub\u2019s regular expressions for this feature are sloppy, so phrases like Partially fixes #1234 will automatically close the issue. Phrases like Fixes part of #1234 are a good alternative. Make as many commits as you need to address the issue or implement your feature.","title":"Commit Changes"},{"location":"gitguide/#push-your-commits-to-github","text":"As you\u2019re working, it\u2019s a good idea to frequently push your changes to GitHub. This ensures your work is backed up should something happen to your local machine and allows others to follow your progress. It also allows you to work from multiple computers without losing work. Pushing to a feature branch is just like pushing to main: $ git push origin <branch-name> Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git * [new branch] issue-demo -> issue- If you want to see what Git will do without actually performing the push, add the -n (dry-run) option: git push -n origin <branch-name> . If everything looks good, re-run the push command without -n. If the feature branch does not already exist on GitHub, it will be created when you push and you\u2019ll see * [new branch] in the command output.","title":"Push your commits to Github"},{"location":"gitguide/#get-and-stay-out-of-trouble","text":"Git is a powerful yet complex version control system. Even for contributors experienced at using version control, it can be confusing. The good news is that nearly all Git actions add information to the Git database, rather than removing it. As such, it\u2019s hard to make Git perform actions that you can\u2019t undo. However, Git can\u2019t undo what it doesn\u2019t know about, so it\u2019s a good practice to frequently commit your changes and frequently push your commits to your remote repository.","title":"Get and stay out of trouble"},{"location":"gitguide/#undo-a-merge-commit","text":"A merge commit is a special type of commit that has two parent commits. It\u2019s created by Git when you merge one branch into another and the last commit on your current branch is not a direct ancestor of the branch you are trying to merge in. This happens quite often in a busy project like Zulip where there are many contributors because upstream/zulip will have new commits while you\u2019re working on a feature or bugfix. In order for Git to merge your changes and the changes that have occurred on zulip/upstream since you first started your work, it must perform a three-way merge and create a merge commit. Merge commits aren\u2019t bad, however, Zulip doesn\u2019t use them. Instead Zulip uses a forked-repo, rebase-oriented workflow. A merge commit is usually created when you\u2019ve run git pull or git merge. You\u2019ll know you\u2019re creating a merge commit if you\u2019re prompted for a commit message and the default is something like this: Merge branch 'main' of https://github.com/yati # Please enter a commit message to explain why this merge is necessary, # especially if it merges an updated upstream into a topic branch. # # Lines starting with '#' will be ignored, and an empty message aborts # the commit. And the first entry for git log will show something like: commit e5f8211a565a5a5448b93e98ed56415255546f94 Merge: 13bea0e e0c10ed Author: Christie Koehler <ck@christi3k.net> Date: Mon Oct 10 13:25:51 2016 -0700 Merge branch 'main' of https://github.com/yati Some graphical Git clients may also create merge commits. To undo a merge commit, first run git reflog to identify the commit you want to roll back to: git reflog e5f8211 HEAD@{0}: pull upstream main: Merge made by the 'recursive' strategy. 13bea0e HEAD@{1}: commit: test commit for docs. Reflog output will be long. The most recent Git refs will be listed at the top. In the example above e5f8211 HEAD@{0} : is the merge commit made automatically by git pull and 13bea0e HEAD@{1}: is the last commit I made before running git pull , the commit that I want to rollback to. Once you\u2019d identified the ref you want to revert to, you can do so with git reset: git reset --hard 13bea0e HEAD is now at 13bea0e test commit for docs.","title":"Undo a merge commit"},{"location":"gitguide/#restore-a-lost-commit","text":"We\u2019ve mentioned you can use git reset --hard to rollback to a previous commit. What if you run git reset --hard and then realize you actually need one or more of the commits you just discarded? No problem, you can restore them with git cherry-pick (docs). For example, let\u2019s say you just committed \u201csome work\u201d and your git log looks like this: * 67aea58 (HEAD -> main) some work * 13bea0e test commit for docs. You then mistakenly run git reset --hard 13bea0e : git reset --hard 13bea0e HEAD is now at 13bea0e test commit for docs. git log * 13bea0e (HEAD -> main) test commit for docs. And then realize you actually needed to keep commit 67aea58. First, use git reflog to confirm that commit you want to restore and then run git cherry-pick : git reflog 13bea0e HEAD@{0}: reset: moving to 13bea0e 67aea58 HEAD@{1}: commit: some work git cherry-pick 67aea58 [main 67aea58] some work Date: Thu Oct 13 11:51:19 2016 -0700 1 file changed, 1 insertion(+) create mode 100644 test4.txt","title":"Restore a lost commit"},{"location":"gitguide2/","text":"Pull Requests Create a pull request When you\u2019re ready for feedback, submit a pull request. Pull requests are a feature specific to GitHub. They provide a simple, web-based way to submit your work (often called \u201cpatches\u201d) to a project. It\u2019s called a pull request because you\u2019re asking the project to pull changes from your fork. If you\u2019re unfamiliar with how to create a pull request, you can check out GitHub\u2019s documentation on creating a pull request from a fork. You might also find GitHub\u2019s article about pull requests helpful. That all said, the tutorial below will walk you through the process. Draft pull requests In the Zulip project, we encourage submitting draft pull requests early and often. This allows you to share your code to make it easier to get feedback and help with your changes, even if you don\u2019t think your pull request is ready to be merged (e.g., it might not work or pass tests). This sets expectations correctly for any feedback from other developers, and prevents your work from being merged before you\u2019re confident in it. Create a pull request Step 0: Make sure you\u2019re on a feature branch (not main ) It is important to work on a feature branch when creating a pull request. Your new pull request will be inextricably linked with your branch while it is open, so you will need to reserve your branch only for changes related to your issue, and avoid introducing extraneous changes for other issues or from upstream. If you are working on a branch named main , you need to create and switch to a feature branch before proceeding. Step 1: Update your branch with git rebase The best way to update your branch is with git fetch and git rebase . Do not use git pull or git merge as this will create merge commits. See keep your fork up to date for details. Here\u2019s an example (you would replace issue-123 with the name of your feature branch): git checkout issue-123 Switched to branch 'issue-123' git fetch upstream remote: Counting objects: 69, done. remote: Compressing objects: 100% (23/23), done. remote: Total 69 (delta 49), reused 39 (delta 39), pack-reused 7 Unpacking objects: 100% (69/69), done. From https://github.com/zulip/zulip 69fa600..43e21f6 main -> upstream/main git rebase upstream/main First, rewinding head to replay your work on top of it... Applying: troubleshooting tip about provisioning Step 2: Push your updated branch to your remote fork Once you\u2019ve updated your local feature branch, push the changes to GitHub: git push origin issue-123 Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git + 2d49e2d...bfb2433 issue-123 -> issue-123 If your push is rejected with error failed to push some refs then you need to prefix the name of your branch with a +: git push origin +issue-123 Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git + 2d49e2d...bfb2433 issue-123 -> issue-123 (forced update) This is perfectly okay to do on your own feature branches, especially if you\u2019re the only one making changes to the branch. If others are working along with you, they might run into complications when they retrieve your changes because anyone who has based their changes off a branch you rebase will have to do a complicated rebase. Step 3: Open the pull request If you\u2019ve never created a pull request or need a refresher, take a look at GitHub\u2019s article on creating a pull request from a fork. We\u2019ll briefly review the process here. First, sign in to GitHub on your web browser and navigate to your fork of Zulip. Next, navigate to the branch you\u2019ve been working on. Do this by clicking on the Branch button and selecting the relevant branch. Finally, click the New pull request button. Alternatively, if you\u2019ve recently pushed the relevant branch to your fork, you will see a Compare & pull request button. A pull request template will open with some information pre-filled in. Provide (or update) the title for your pull request and write a first comment. If your pull request makes UI changes, always include one or more still screenshots to demonstrate your changes. If it seems helpful, add a screen capture of the new functionality as well. You can find a list of tools you can use for this here. See the documentation for creating reviewable pull requests for more guidance and tips when writing pull request comments. If the repository has a self-review checklist in the pull request template, make sure that all the relevant points have been addressed before submitting it. When ready, click the Create pull request button to submit the pull request. Remember to mark your pull request as a draft if it is a work-in-progress. Note: Pull request titles are different from commit messages. Commit messages can be edited with git commit --amend, git rebase -i , etc., while the title of a pull request can only be edited via GitHub. Update a pull request As you get make progress on your feature or bugfix, your pull request, once submitted, will be updated each time you push commits to your remote branch. This means you can keep your pull request open as long as you need, rather than closing and opening new ones for the same feature or bugfix. It\u2019s a good idea to keep your pull request mergeable with Zulip upstream by frequently fetching, rebasing, and pushing changes. See keep your fork up to date for details. You might also find this excellent article How to Rebase a Pull Request helpful. And, as you address review comments others have made, we recommend posting a follow-up comment in which you: a) ask for any clarifications you need, b) explain to the reviewer how you solved any problems they mentioned, and c) ask for another review.","title":"Pull Requests"},{"location":"gitguide2/#pull-requests","text":"","title":"Pull Requests"},{"location":"gitguide2/#create-a-pull-request","text":"When you\u2019re ready for feedback, submit a pull request. Pull requests are a feature specific to GitHub. They provide a simple, web-based way to submit your work (often called \u201cpatches\u201d) to a project. It\u2019s called a pull request because you\u2019re asking the project to pull changes from your fork. If you\u2019re unfamiliar with how to create a pull request, you can check out GitHub\u2019s documentation on creating a pull request from a fork. You might also find GitHub\u2019s article about pull requests helpful. That all said, the tutorial below will walk you through the process.","title":"Create a pull request"},{"location":"gitguide2/#draft-pull-requests","text":"In the Zulip project, we encourage submitting draft pull requests early and often. This allows you to share your code to make it easier to get feedback and help with your changes, even if you don\u2019t think your pull request is ready to be merged (e.g., it might not work or pass tests). This sets expectations correctly for any feedback from other developers, and prevents your work from being merged before you\u2019re confident in it.","title":"Draft pull requests"},{"location":"gitguide2/#create-a-pull-request_1","text":"Step 0: Make sure you\u2019re on a feature branch (not main ) It is important to work on a feature branch when creating a pull request. Your new pull request will be inextricably linked with your branch while it is open, so you will need to reserve your branch only for changes related to your issue, and avoid introducing extraneous changes for other issues or from upstream. If you are working on a branch named main , you need to create and switch to a feature branch before proceeding. Step 1: Update your branch with git rebase The best way to update your branch is with git fetch and git rebase . Do not use git pull or git merge as this will create merge commits. See keep your fork up to date for details. Here\u2019s an example (you would replace issue-123 with the name of your feature branch): git checkout issue-123 Switched to branch 'issue-123' git fetch upstream remote: Counting objects: 69, done. remote: Compressing objects: 100% (23/23), done. remote: Total 69 (delta 49), reused 39 (delta 39), pack-reused 7 Unpacking objects: 100% (69/69), done. From https://github.com/zulip/zulip 69fa600..43e21f6 main -> upstream/main git rebase upstream/main First, rewinding head to replay your work on top of it... Applying: troubleshooting tip about provisioning Step 2: Push your updated branch to your remote fork Once you\u2019ve updated your local feature branch, push the changes to GitHub: git push origin issue-123 Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git + 2d49e2d...bfb2433 issue-123 -> issue-123 If your push is rejected with error failed to push some refs then you need to prefix the name of your branch with a +: git push origin +issue-123 Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 658 bytes | 0 bytes/s, done. Total 6 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 1 local objects. To git@github.com:christi3k/zulip.git + 2d49e2d...bfb2433 issue-123 -> issue-123 (forced update) This is perfectly okay to do on your own feature branches, especially if you\u2019re the only one making changes to the branch. If others are working along with you, they might run into complications when they retrieve your changes because anyone who has based their changes off a branch you rebase will have to do a complicated rebase. Step 3: Open the pull request If you\u2019ve never created a pull request or need a refresher, take a look at GitHub\u2019s article on creating a pull request from a fork. We\u2019ll briefly review the process here. First, sign in to GitHub on your web browser and navigate to your fork of Zulip. Next, navigate to the branch you\u2019ve been working on. Do this by clicking on the Branch button and selecting the relevant branch. Finally, click the New pull request button. Alternatively, if you\u2019ve recently pushed the relevant branch to your fork, you will see a Compare & pull request button. A pull request template will open with some information pre-filled in. Provide (or update) the title for your pull request and write a first comment. If your pull request makes UI changes, always include one or more still screenshots to demonstrate your changes. If it seems helpful, add a screen capture of the new functionality as well. You can find a list of tools you can use for this here. See the documentation for creating reviewable pull requests for more guidance and tips when writing pull request comments. If the repository has a self-review checklist in the pull request template, make sure that all the relevant points have been addressed before submitting it. When ready, click the Create pull request button to submit the pull request. Remember to mark your pull request as a draft if it is a work-in-progress. Note: Pull request titles are different from commit messages. Commit messages can be edited with git commit --amend, git rebase -i , etc., while the title of a pull request can only be edited via GitHub.","title":"Create a pull request"},{"location":"gitguide2/#update-a-pull-request","text":"As you get make progress on your feature or bugfix, your pull request, once submitted, will be updated each time you push commits to your remote branch. This means you can keep your pull request open as long as you need, rather than closing and opening new ones for the same feature or bugfix. It\u2019s a good idea to keep your pull request mergeable with Zulip upstream by frequently fetching, rebasing, and pushing changes. See keep your fork up to date for details. You might also find this excellent article How to Rebase a Pull Request helpful. And, as you address review comments others have made, we recommend posting a follow-up comment in which you: a) ask for any clarifications you need, b) explain to the reviewer how you solved any problems they mentioned, and c) ask for another review.","title":"Update a pull request"},{"location":"overview/","text":"Yati Overview Yati is mobile application built using the Flutter Framework. It is designed to provide answers to questions about services provided by governement ministries and their departments. Getting Started Contributing code. Check out our guide for new contributors to get started. We have invested in making Yati code highly readable, thoughtfully tested, and easy to modify. Beyond that, we encourage contributors to follow our guidelines on documentation to ensure everything changed is documented. Contributing non-code. Reporting an issue and give us feedback. We\u2019d love to hear from you, whether you want to contribute to Yati or are just trying it out for the first time. Checking Yati out. The best way to expireance and use Yati is to download and install Yati App APK. We also recommend joining and following our communities to ask any questions. You may also be interested in following us on Twitter and LinkedIn . Licences. Yati is distributed under the Apache 2.0 license. To learn more about Yati's distribution license, follow this link Yati Architecture Overview Key Codebases The main Yati codebase is at https://github.com/Fanelemenzi/Yati . Iit contains all the frontend and backend code for the Yati Mobile App. Yati Mobile app is a mobile app built on with the flutter framework supporting both iOS and Andriod written with Python and HTML to support some app functions. Usage Assumptions and Concepts Yati is a information application provide answers to questions about services and products provided by the Eswatini Government. Information is structured in form of FAQs with answers. It is divided by deaprtments with each department getting its own set of questions and answers. Architecture Components Flutter and APIs Yati's is primarily implemented in the Flutter cross platform framework with APIs calling data stored on a codebase. Flutter with dart provides the UI of the application and backend logic allowing/providing functionality to the application UI. The API provide the backend functionality by getting data from database. Directory Structure This page documents the Yati directory structure, where to find things, and how to decide where to put a file. Core Folders and Files Yati uses the Flutter crossplartform framework, some of this path are default packages and folders coming with the flutter framework. Folders and Files that can be changed are the working part of the project are expanded and explains in great detail further down this section. These are [lib], [Docs], [pubspec.yaml]. yati/.dart_tool - This folder comes with dart version 2 and used by pub and other tools. It replaced the .pub directory. yati/andriod - This folder contains native andriod code. Most of the time you dont need to change anything inside this folder but of you want to intercat with low level functions (eg. camera, bluetooth, gps) you need to edit this folder. yati/assets - This folder contains assests used throughout the project such images, videos, icons and more yati/Docs - this is the documentation folder that contains all the files dealing with the documentation of any changes in the development of the Yati app. yati/ios - this folder contains native iOS code. yati/lib - This is the folder where we will be mostly hanging around in because we will write our Flutter code into this folder. By default lib folder contians only the main.dart file. The main.dart file is like the a car ignition becuase the app starts running from the main.dart file. The folder structure inside lib is important for organizing and managing the application. yati/linux - Same as andriod folder, contians native code to run application on Linux software yati/macos - Folder contains native code torun software on MacOS operating systems. yati/test - This is the folder where we will write our test for the application. yati/web - This folder contains code to run the application on web browsers yati/windows - This folder contains native code that allows app to run on windows OS. yati/.readthedocs.yaml - file that allows for the app documentation to be hosted on ReadTheDocs. yati/.analysis_options/yaml - This is a file configuration which configures Dart analyzer which checks all your code and if your code has any conflict with the configurations you wrote then IDE gives an error or warning. yati/pubspec.lock - This file contains all the packages versions, dependency and description informations used in the project. Purpose is to keep the app packages locked in the same library version so if wwe run the app in different computers we dont have to struggle with code issue caused from different package versions. yati/pubspec.yaml - This file controls app name, SDK version, packages, dependencies and assets. If you want to add new packages to your project you need to add the package name under dependencies section. yati/READMe.md - This is the default markdown file containing resources to get started into Flutter for beginners. Lib Folder yati/lib/Constants/ contains constant static files that do not during the function of the project. This files are non-volatile. In this folder there is the ../lib/Constants/department.dart contains a class containing a list of strings used to label all the departments used throughout the codebase. ..lib/Constants/ministries.dart contains a class containing a list of strings used to label all the minitries in the codebase. yati/lib/dep_pages folder contains folders with the business logic for eachof the departments FAQs ../dep_pages/Deputy PM Office/ contains the social_welfare_department.dart file that runs the business logic of the social welfare department FAQs . ../dep_pages/Ministry of Agriculture contains the vet_livestock_production.dart file which controls the logic for the vet livestock production department FAQs . ../dep_pages/Ministry of Commerce contains the cooperative_development.dart , Liquor_department.dart and the regristrar_of_companies.dart files that control the logic of the Cooperative Development FAQs , the Liqour Department FAQs and the Regristrar of Companies FAQs . ../dep_pages/Ministry of Home Affairs contains the home_affairs.dart file which controls the logic and function of the Home Affairs Department FAQs . ../dep_pages/Ministry of Labour contains the Industrial_and_Vocational_training.dart and the scholarship.dart files which control the functioning and business logic for the Industrial and Vocational Training Department FAQs and the Scholarship Department FAQs . yati/lib/Screens/ folder contains the files that controls and renders the presentation layer for the app that users interact with. yati/Screens/about.dart This dart file renders the about page in the application. yati/Screens/most_used.dart This dart file renders the Most Used page in the application. yati/Screens/profile.dart This file renders the profile page on the application. yati/Screens/welcome_page.dart This file renders the welcome page which is the first page user interacts with. yati/lib/bottom_navbar.dart controls and renders the bottom navigation bar of the application. yati/lib/opening_screen.dart controls and renders the opening screens with runs for 5 seconds before the welcome page. yati/lib/main.dart the file where the application starts running. Its controls the whole rendering of the application. Documentation /Docs/ This folder contains all the application documentation files that are used to track any changes made to the project.","title":"Overview"},{"location":"overview/#yati-overview","text":"Yati is mobile application built using the Flutter Framework. It is designed to provide answers to questions about services provided by governement ministries and their departments.","title":"Yati Overview"},{"location":"overview/#getting-started","text":"Contributing code. Check out our guide for new contributors to get started. We have invested in making Yati code highly readable, thoughtfully tested, and easy to modify. Beyond that, we encourage contributors to follow our guidelines on documentation to ensure everything changed is documented. Contributing non-code. Reporting an issue and give us feedback. We\u2019d love to hear from you, whether you want to contribute to Yati or are just trying it out for the first time. Checking Yati out. The best way to expireance and use Yati is to download and install Yati App APK. We also recommend joining and following our communities to ask any questions. You may also be interested in following us on Twitter and LinkedIn .","title":"Getting Started"},{"location":"overview/#licences","text":"Yati is distributed under the Apache 2.0 license. To learn more about Yati's distribution license, follow this link","title":"Licences."},{"location":"overview/#yati-architecture-overview","text":"","title":"Yati Architecture Overview"},{"location":"overview/#key-codebases","text":"The main Yati codebase is at https://github.com/Fanelemenzi/Yati . Iit contains all the frontend and backend code for the Yati Mobile App. Yati Mobile app is a mobile app built on with the flutter framework supporting both iOS and Andriod written with Python and HTML to support some app functions.","title":"Key Codebases"},{"location":"overview/#usage-assumptions-and-concepts","text":"Yati is a information application provide answers to questions about services and products provided by the Eswatini Government. Information is structured in form of FAQs with answers. It is divided by deaprtments with each department getting its own set of questions and answers.","title":"Usage Assumptions and Concepts"},{"location":"overview/#architecture-components","text":"","title":"Architecture Components"},{"location":"overview/#flutter-and-apis","text":"Yati's is primarily implemented in the Flutter cross platform framework with APIs calling data stored on a codebase. Flutter with dart provides the UI of the application and backend logic allowing/providing functionality to the application UI. The API provide the backend functionality by getting data from database.","title":"Flutter and APIs"},{"location":"overview/#directory-structure","text":"This page documents the Yati directory structure, where to find things, and how to decide where to put a file.","title":"Directory Structure"},{"location":"overview/#core-folders-and-files","text":"Yati uses the Flutter crossplartform framework, some of this path are default packages and folders coming with the flutter framework. Folders and Files that can be changed are the working part of the project are expanded and explains in great detail further down this section. These are [lib], [Docs], [pubspec.yaml]. yati/.dart_tool - This folder comes with dart version 2 and used by pub and other tools. It replaced the .pub directory. yati/andriod - This folder contains native andriod code. Most of the time you dont need to change anything inside this folder but of you want to intercat with low level functions (eg. camera, bluetooth, gps) you need to edit this folder. yati/assets - This folder contains assests used throughout the project such images, videos, icons and more yati/Docs - this is the documentation folder that contains all the files dealing with the documentation of any changes in the development of the Yati app. yati/ios - this folder contains native iOS code. yati/lib - This is the folder where we will be mostly hanging around in because we will write our Flutter code into this folder. By default lib folder contians only the main.dart file. The main.dart file is like the a car ignition becuase the app starts running from the main.dart file. The folder structure inside lib is important for organizing and managing the application. yati/linux - Same as andriod folder, contians native code to run application on Linux software yati/macos - Folder contains native code torun software on MacOS operating systems. yati/test - This is the folder where we will write our test for the application. yati/web - This folder contains code to run the application on web browsers yati/windows - This folder contains native code that allows app to run on windows OS. yati/.readthedocs.yaml - file that allows for the app documentation to be hosted on ReadTheDocs. yati/.analysis_options/yaml - This is a file configuration which configures Dart analyzer which checks all your code and if your code has any conflict with the configurations you wrote then IDE gives an error or warning. yati/pubspec.lock - This file contains all the packages versions, dependency and description informations used in the project. Purpose is to keep the app packages locked in the same library version so if wwe run the app in different computers we dont have to struggle with code issue caused from different package versions. yati/pubspec.yaml - This file controls app name, SDK version, packages, dependencies and assets. If you want to add new packages to your project you need to add the package name under dependencies section. yati/READMe.md - This is the default markdown file containing resources to get started into Flutter for beginners.","title":"Core Folders and Files"},{"location":"overview/#lib-folder","text":"yati/lib/Constants/ contains constant static files that do not during the function of the project. This files are non-volatile. In this folder there is the ../lib/Constants/department.dart contains a class containing a list of strings used to label all the departments used throughout the codebase. ..lib/Constants/ministries.dart contains a class containing a list of strings used to label all the minitries in the codebase. yati/lib/dep_pages folder contains folders with the business logic for eachof the departments FAQs ../dep_pages/Deputy PM Office/ contains the social_welfare_department.dart file that runs the business logic of the social welfare department FAQs . ../dep_pages/Ministry of Agriculture contains the vet_livestock_production.dart file which controls the logic for the vet livestock production department FAQs . ../dep_pages/Ministry of Commerce contains the cooperative_development.dart , Liquor_department.dart and the regristrar_of_companies.dart files that control the logic of the Cooperative Development FAQs , the Liqour Department FAQs and the Regristrar of Companies FAQs . ../dep_pages/Ministry of Home Affairs contains the home_affairs.dart file which controls the logic and function of the Home Affairs Department FAQs . ../dep_pages/Ministry of Labour contains the Industrial_and_Vocational_training.dart and the scholarship.dart files which control the functioning and business logic for the Industrial and Vocational Training Department FAQs and the Scholarship Department FAQs . yati/lib/Screens/ folder contains the files that controls and renders the presentation layer for the app that users interact with. yati/Screens/about.dart This dart file renders the about page in the application. yati/Screens/most_used.dart This dart file renders the Most Used page in the application. yati/Screens/profile.dart This file renders the profile page on the application. yati/Screens/welcome_page.dart This file renders the welcome page which is the first page user interacts with. yati/lib/bottom_navbar.dart controls and renders the bottom navigation bar of the application. yati/lib/opening_screen.dart controls and renders the opening screens with runs for 5 seconds before the welcome page. yati/lib/main.dart the file where the application starts running. Its controls the whole rendering of the application.","title":"Lib Folder"},{"location":"overview/#documentation","text":"/Docs/ This folder contains all the application documentation files that are used to track any changes made to the project.","title":"Documentation"},{"location":"user-manual/","text":"","title":"User-manual"}]}